<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>&lt;no title&gt; &#8212; netket v3.0 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jumbo-style.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/all.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/rtd_theme.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../_static/js/rtd_theme.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/logonav.png"></span>
          NetKet</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../getting_started.html">Get Started</a></li>
                <li><a href="../docs/getting_started.html">Documentation</a></li>
                <li><a href="../tutorials.html">Tutorials</a></li>
                <li><a href="../citing.html">Citing NetKet</a></li>
                <li><a href="../about.html">About</a></li>
                <li><a href="https://github.com/netket/netket"><i class="fab fa-github" aria-hidden="true"></i></a></li>
                <li><a href="https://twitter.com/NetKetOrg"><i class="fab fa-twitter" aria-hidden="true"></i></a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <dl>
<dt>{</dt><dd><dl>
<dt>“cells”: [</dt><dd><dl>
<dt>{</dt><dd><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“# Using JAX as a backend in NetKet - Feature Preview for v3.0 n”,
“n”,
“In this tutorial we will show how differentiable functions (for example deep networks) written in [JAX](<a class="reference external" href="https://github.com/google/jax">https://github.com/google/jax</a>) can be used as variational quantum states in NetKet. n”,
“n”,
“This feature will be available in the upcoming major release (version 3.0). While version 3.0 is still in beta development, users can already try this feature. n”,
“n”,
“n”,
“## Prerequisites n”,
“n”,
“To try out integration with JAX, you first need to fetch the beta version of NetKet v3 n”,
“We recommend using a virtual environment (either a python environment or a conda environment), for examplen”,
“n”,
“<code class="docutils literal notranslate"><span class="pre">`shell\n&quot;,</span>
<span class="pre">&quot;python3</span> <span class="pre">-m</span> <span class="pre">venv</span> <span class="pre">nk_env\n&quot;,</span>
<span class="pre">&quot;source</span> <span class="pre">nk_env/bin/activate\n&quot;,</span>
<span class="pre">&quot;pip</span> <span class="pre">install</span> <span class="pre">--pre</span> <span class="pre">-U</span> <span class="pre">netket\n&quot;,</span>
<span class="pre">&quot;`</span></code>n”,
“n”,
“## Defining the quantum system n”,
“n”,
“NetKet allows for full flexibility in defining quantum systems, for example when tackling a ground-state search problem. While there are a few pre-defined hamiltonians, it is relatively straightforward to implement new quantum operators/ Hamiltonians. n”,
“n”,
“In the following, we consider the case of a transverse-field Ising model defined on a graph with random edges. n”,
“n”,
“$$ H = -\sum_{i\in\textrm{nodes}}^{L} \sigma^x_{i} + J \sum_{(i,j)\in\textrm{edges}}\sigma_{i}^{z}\sigma_{j}^{z} $$  “</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 1,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“# ensure we run on the CPU and not on the GPUn”,
“import osn”,
“os.environ[&quot;JAX_PLATFORM_NAME&quot;] = &quot;cpu&quot;n”,
“n”,
“import netket as nkn”,
“n”,
“#Define a random graphn”,
“n_nodes=10n”,
“n_edges=20n”,
“from numpy.random import choicen”,
“rand_edges=[choice(n_nodes, size=2,replace=False).tolist() for i in range(n_edges)]n”,
“n”,
“graph=nk.graph.Graph(nodes=[i for i in range(n_nodes)], edges=rand_edges)n”,
“n”,
“#Define the local hilbert spacen”,
“hi=nk.hilbert.Spin(s=0.5)**graph.n_nodesn”,
“n”,
“#Define the Hamiltonian as a sum of local operators n”,
“from netket.operator import LocalOperator as Opn”,
“n”,
“# Pauli Matricesn”,
“sx = [[0, 1], [1, 0]]n”,
“sz = [[1, 0], [0, -1]]n”,
“n”,
“# Defining the Hamiltonian as a LocalOperator acting on the given Hilbert spacen”,
“ha = Op(hi)n”,
“n”,
“#Adding a transverse field term on each node of the graphn”,
“for i in range(graph.n_nodes):n”,
”    ha += Op(hi, sx, [i])n”,
“n”,
“#Adding nearest-neighbors interactions on the edges of the given graphn”,
“from numpy import kronn”,
“J=0.5n”,
“for edge in graph.edges():n”,
”    ha += J*Op(hi, kron(sz, sz), edge)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {},
“outputs”: [],
“source”: []</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“## Defining a JAX module to be used as a wave functionn”,
“n”,
“We now want to define a suitable JAX wave function to be used as a wave function ansatz. To simplify the discusssion, we consider here a simple single-layer fully connected network with complex weights and a $tanh$ activation function. These are easy to define in JAX, using for example a model built with [STAX](<a class="reference external" href="https://github.com/google/jax/tree/master/jax/experimental">https://github.com/google/jax/tree/master/jax/experimental</a>). The only requirement is that these networks take as  inputs JAX arrays of shape <code class="docutils literal notranslate"><span class="pre">`(batch_size,n)`</span></code>, where batch_size is an arbitrary <code class="docutils literal notranslate"><span class="pre">`batch</span> <span class="pre">size`</span></code> and <code class="docutils literal notranslate"><span class="pre">`n`</span></code> is the number of quantum degrees of freedom (for example, the number of spins, in the previous example). Notice that regardless of the dimensionality of the problem, the last dimension is always flattened into a single index.  n”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 2,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“import jaxn”,
“from jax.experimental import staxn”,
“n”,
“#We define a custom layer that performs the sum of its inputs n”,
“def SumLayer():n”,
”    def init_fun(rng, input_shape):n”,
”        output_shape = (-1, 1)n”,
”        return output_shape, ()n”,
“n”,
”    def apply_fun(params, inputs, <a href="#id1"><span class="problematic" id="id2">**</span></a>kwargs):n”,
”        return inputs.sum(axis=-1)n”,
“n”,
”    return init_fun, apply_funn”,
“n”,
“#We construct a fully connected network with tanh activation n”,
“model=stax.serial(stax.Dense(2 * graph.n_nodes, W_init=nk.nn.initializers.normal(stddev=0.1, dtype=complex), n”,
”                             b_init=nk.nn.initializers.normal(stddev=0.1, dtype=complex)), n”,
”                  stax.Tanh,SumLayer())n”,
“n”,
“# Alternatively, we could have used flax, which would have been easier:n”,
“#class Model(nk.nn.Module):n”,
“#    &#64;nk.nn.compactn”,
“#    def __call__(self, x):n”,
“#        x = nk.nn.Dense(features=2*x.shape[-1], dtype=complex, kernel_init=nk.nn.initializers.normal(stddev=0.01), bias_init=nk.nn.initializers.normal(stddev=0.01))(x)n”,
“#        x = jax.numpy.tanh(x)n”,
“#        return jax.numpy.sum(x, axis=-1)   n”,
“#model = Model()n”,
“n”,
“# Alternatively #2 we could have used the built in RBM model:n”,
“#model = nk.models.RBM(alpha=2, use_visible_bias=False, dtype=np.complex128)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“## Train the neural network to find an approximate ground staten”,
“n”,
“In order to perform Variational Monte Carlo, we further need to specify a suitable n”,
“sampler (to compute expectation values over the variational state) as well as n”,
“an optimizer. In the following we will adopt the Stochatic Gradient Descent coupledn”,
“with quantum natural gradients (this scheme is known in the VMC literature as Stochastic Reconfiguration)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 3,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“# Defining a sampler that performs local movesn”,
“# NetKet automatically dispatches here to MCMC sampler written using JAX typesn”,
“sa = nk.sampler.MetropolisLocal(hilbert=hi, n_chains=2)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 4,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“# Construct the variational staten”,
“vs = nk.variational.MCState(sa, model, n_samples=1000)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 5,
“metadata”: {},
“outputs”: [],
“source”: [</p>
<blockquote>
<div><p>“# Using Sgdn”,
“# Also dispatching to JAX optimizern”,
“op = nk.optimizer.Sgd(learning_rate=0.01)n”,
“n”,
“# Using Stochastic Reconfiguration a.k.a. quantum natural gradientn”,
“# Also dispatching to a pure JAX versionn”,
“sr = nk.optimizer.SR(diag_shift=0.01)n”,
“n”,
“# Create the Variational Monte Carlo instance to learn the ground staten”,
“vmc = nk.VMC(n”,
”    hamiltonian=ha, optimizer=op, variational_state=vs, preconditioner=srn”,
“)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: null,
“metadata”: {},
“outputs”: [],
“source”: []</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“### Running the training loop n”,
“n”,
“The last version of NetKet also allows for a finer control of the vmc loop. In the simplest case, one can just iterate through the vmc object and print the current value of the energy. More sophisticated output schemes based on tensorboard have been also implemented, but are not discussed in this Tutorial. “</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 6,
“metadata”: {},
“outputs”: [</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>“name”: “stdout”,
“output_type”: “stream”,
“text”: [</p>
<blockquote>
<div><p>“0 6.20-0.02j ± 0.12 [σ²=13.25, R̂=0.9994]n”,
“50 -5.98-0.06j ± 0.14 [σ²=9.84, R̂=0.9992]n”,
“100 -10.04-0.08j ± 0.11 [σ²=10.24, R̂=0.9995]n”,
“150 -10.907+0.014j ± 0.042 [σ²=1.230, R̂=1.0001]n”,
“200 -11.261-0.014j ± 0.034 [σ²=0.855, R̂=0.9993]n”,
“250 -11.396-0.013j ± 0.024 [σ²=1.402, R̂=0.9993]n”,
“300 -11.532+0.015j ± 0.015 [σ²=0.198, R̂=1.0000]n”,
“350 -11.727-0.002j ± 0.019 [σ²=0.196, R̂=1.0028]n”,
“400 -11.830-0.013j ± 0.017 [σ²=0.105, R̂=1.0051]n”,
“450 -11.872+0.011j ± 0.010 [σ²=0.055, R̂=0.9991]n”</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>],
“source”: [</p>
<blockquote>
<div><p>“# Running the learning loop and printing the energy every 50 stepsn”,
“# [notice that the very first iteration is slow because of JIT compilation]n”,
“for it in vmc.iter(500,50):n”,
”    print(it,vmc.energy)”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “markdown”,
“metadata”: {},
“source”: [</p>
<blockquote>
<div><p>“## Comparing to exact diagonalizationn”,
“n”,
“Since this is a relatively small quantum system, we can still diagonalize the Hamiltonian using exact diagonalization. For this purpose, NetKet conveniently exposes a <code class="docutils literal notranslate"><span class="pre">`.to_sparse`</span></code> method that just converts the Hamiltonian into a <code class="docutils literal notranslate"><span class="pre">`scipy`</span></code> sparse matrix.n”,
“Here we first obtain this sparse matrix, and then diagonalize it with scipy builtins. “</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>“cell_type”: “code”,
“execution_count”: 7,
“metadata”: {},
“outputs”: [</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>“name”: “stdout”,
“output_type”: “stream”,
“text”: [</p>
<blockquote>
<div><p>“Exact energy is :  -11.932889012463688n”,
“Relative error is :  0.0034391959338140226n”</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>],
“source”: [</p>
<blockquote>
<div><p>“import scipyn”,
“exact_ens=scipy.sparse.linalg.eigsh(ha.to_sparse(),k=1,which=’SA’,return_eigenvectors=False)n”,
“print(&quot;Exact energy is : &quot;,exact_ens[0])n”,
“print(&quot;Relative error is : &quot;, (abs((vmc.energy.mean-exact_ens[0])/exact_ens[0])))”</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>],
“metadata”: {</p>
<blockquote>
<div><dl class="simple">
<dt>“kernelspec”: {</dt><dd><p>“display_name”: “Python (Netket development)”,
“language”: “python”,
“name”: “dev-netket”</p>
</dd>
</dl>
<p>},
“language_info”: {</p>
<blockquote>
<div><dl class="simple">
<dt>“codemirror_mode”: {</dt><dd><p>“name”: “ipython”,
“version”: 3</p>
</dd>
</dl>
<p>},
“file_extension”: “.py”,
“mimetype”: “text/x-python”,
“name”: “python”,
“nbconvert_exporter”: “python”,
“pygments_lexer”: “ipython3”,
“version”: “3.8.10”</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>},
“nbformat”: 4,
“nbformat_minor”: 4</p>
</dd>
</dl>
<p>}</p>


    </div>
      
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2019-2021, The Netket authors - All rights reserved.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.4.<br/>
    </p>
  </div>
</footer>

<script type="text/javascript">
    jQuery(function () {
        SphinxRtdTheme.Navigation.enable(true);
      })
</script>

<!-- Temporary footer
<div class="footer-wip">
  <div class="footer-wip-content">
    This documentation refers to an unreleased version of Netket.
  </div>
</div>
-->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-118013987-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-118013987-1');
</script>

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "url": "https://www.netket.org",
  "name": "NetKet",
  "founder": "Giuseppe Carleo",
  "foundingDate": "2018-04-24",
  "foundingLocation" : "New York",
  "logo": "https://www.netket.org/img/logo_small.jpg",
  "sameAs": [
    "https://twitter.com/NetKetOrg",
    "https://github.com/NetKet/netket"
  ],
  "description" : "Netket is an open-source project delivering cutting-edge
  methods for the study of many-body quantum systems with artificial neural
  networks and machine learning techniques."
}
</script>

  </body>
</html>